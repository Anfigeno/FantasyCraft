import AccionesBase from "@lib/AccionesBase";
import { 
  Interaction,
  CommandInteraction,
  EmbedBuilder,
  StringSelectMenuOptionBuilder,
  StringSelectMenuInteraction,
  StringSelectMenuBuilder,
  ModalSubmitInteraction,
  TextInputBuilder,
  TextInputStyle,
  ModalBuilder,
  ActionRowBuilder,
  GuildMember,
  GuildTextBasedChannel,
  PermissionFlagsBits,
  ButtonBuilder,
  ButtonStyle,
  ButtonInteraction
} from "discord.js";

export default class PanelDeTickets < AccionesBase 
  private @ async crearEmbedResumen(miniatura: string): Promise<EmbedBuilder>
    embed := await this.crearEmbedEstilizado()
    embed
      .setTitle "Tickets | FantasyCraft"
      .setDescription """
        Bienvenido al soporte de FantasyCraft.
        Selecciona la categoría que más se adecúe con tu necesidad y crearemos un ticket por ti.

        > De esta forma podrás ponerte en contacto con uno de nuestos miembros del equipo y así tratar de ayudarte a solucionar tu problema
        """
      .setThumbnail miniatura

  private @ listaDeOpciones(): ActionRowBuilder<StringSelectMenuBuilder>
    new ActionRowBuilder<StringSelectMenuBuilder>()
      .setComponents(
        new StringSelectMenuBuilder()
          .setOptions [
            OpcionDudas.opcion
            OpcionBugs.opcion
            OpcionApelacion.opcion
            OpcionDonacion.opcion
            OpcionOtros.opcion
          ]
          .setCustomId "panel-de-tickets-opciones"
      )
  
  private @ async crearPanelDeTickets(interaccion: CommandInteraction): Promise<void>
    if interaccion.commandName is not "panel-de-tickets" return
    if not @esAdmin interaccion.member as GuildMember return

    avatarBot := interaccion.client.user.avatarURL()

    await interaccion.reply
      embeds: [ await @crearEmbedResumen avatarBot ]
      components: [ @listaDeOpciones() ]

  public @ async manejarInteraccion(interaccion: Interaction): Promise<void>
    if interaccion.isCommand()
      //
      await @crearPanelDeTickets interaccion
      //
    else if interaccion.isStringSelectMenu()
      //
      await OpcionDudas.mostrarModalRecolector interaccion
      await OpcionBugs.mostrarModalRecolector interaccion
      await OpcionApelacion.mostrarModalRecolector interaccion
      await OpcionDonacion.mostrarModalRecolector interaccion
      await OpcionOtros.mostrarModalRecolector interaccion
      //
    else if interaccion.isModalSubmit()
      //
      await OpcionDudas.crearTicket interaccion
      await OpcionBugs.crearTicket interaccion
      await OpcionApelacion.crearTicket interaccion
      await OpcionDonacion.crearTicket interaccion
      await OpcionOtros.crearTicket interaccion
      //
    else if interaccion.isButton()
      //
      await Tickets.cerrarTicket interaccion
      await Tickets.reabrirTicket interaccion
      await Tickets.publicarTicket interaccion
      await Tickets.eliminarTicket interaccion


class OpcionDudas < AccionesBase
  @opcion = new StringSelectMenuOptionBuilder()
    .setLabel "Dudas"
    .setEmoji "🤔"
    .setValue "dudas"

  @ async mostrarModalRecolector(interaccion: StringSelectMenuInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-opciones" return
    if interaccion.values[0] is not "dudas" return
  
    campos: TextInputBuilder[] := [
      new TextInputBuilder()
        .setLabel "Cuál es tu duda?"
        .setStyle TextInputStyle.Paragraph
        .setRequired true
        .setCustomId "dudas"
    ]

    modal := new ModalBuilder()
      .setCustomId "panel-de-tickets-modal-dudas"
      .setTitle "🤔 Crear ticket de dudas"
      .setComponents campos.map (campo) =>
        new ActionRowBuilder<TextInputBuilder>().setComponents campo

    await interaccion.showModal modal
  
  @ async crearTicket(interaccion: ModalSubmitInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-modal-dudas" return

    { fields: campos, user: usuario } := interaccion
    datos :=
      duda: campos.getTextInputValue "dudas"

    canalTicket := await Tickets.nuevo interaccion, "🤔-dudas"
    if canalTicket is null
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true
      
      return

    embed := await @crearEmbedEstilizado()
    embed
      .setTitle "🤔 Ticket de dudas"
      .setFields [
        name: "Creador del ticket"
        value: `> ${usuario.username}`
        ,
        name: "Dudas"
        value: datos.duda
          .split "\n"
          .map (linea) => `> ${linea}`
          .join "\n"
      ]

    { rolesDeAdministracion } := @api
    await rolesDeAdministracion.obtener()

    await canalTicket.send
      content: `${usuario} - <@&${rolesDeAdministracion.idAdministrador}>`
      embeds: [ embed ]
      components: [ Tickets.crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: `Ticket creado en ${canalTicket}`
      ephemeral: true

class OpcionBugs < AccionesBase
  @opcion := new StringSelectMenuOptionBuilder()
    .setLabel "Bugs"
    .setEmoji "🐛"
    .setValue "bugs"

  public @ async mostrarModalRecolector(interaccion: StringSelectMenuInteraction): Promise<void>
    if (
      interaccion.customId is not "panel-de-tickets-opciones"
      or interaccion.values[0] is not "bugs" 
    ) return

    campos: TextInputBuilder[] := [
      new TextInputBuilder()
        .setLabel "Tipo de bug"
        .setStyle TextInputStyle.Short
        .setRequired true
        .setCustomId "tipo"
      new TextInputBuilder()
        .setLabel "Descripción del bug"
        .setStyle TextInputStyle.Paragraph
        .setRequired true
        .setCustomId "descripcion"
    ]

    modal := new ModalBuilder()
      .setCustomId "panel-de-tickets-modal-bugs"
      .setTitle "🐛 Crear ticket de bugs"
      .setComponents campos.map (campo) =>
        new ActionRowBuilder<TextInputBuilder>().setComponents campo
    
    await interaccion.showModal modal
  
  public @ async crearTicket(interaccion: ModalSubmitInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-modal-bugs" return

    canalTicket := await Tickets.nuevo interaccion, "🐛-bugs"
    if canalTicket is null
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true

      return

    { fields: campos, user: usuario } := interaccion
    
    datos :=
      tipo: campos.getTextInputValue "tipo"
      descripcion: campos.getTextInputValue "descripcion"
    
    embed := await @crearEmbedEstilizado()
    embed
      .setTitle "🐛 Ticket de bugs"
      .setFields [
        name: "Tipo de bug"
        value: datos.tipo
        ,
        name: "Descripción del bug"
        value: datos.descripcion
          .split "\n"
          .map (linea) => `> ${linea}`
          .join "\n"
      ]

    { rolesDeAdministracion } := @api
    await rolesDeAdministracion.obtener()

    await canalTicket.send
      content: `${usuario} - <@&${rolesDeAdministracion.idAdministrador}>`
      embeds: [ embed ]
      components: [ Tickets.crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: `Ticket creado en ${canalTicket}`
      ephemeral: true

class OpcionApelacion < AccionesBase
  @opcion := new StringSelectMenuOptionBuilder()
    .setLabel "Apelacion"
    .setEmoji "🙏"
    .setValue "apelacion"

  public @ async mostrarModalRecolector(interaccion: StringSelectMenuInteraction): Promise<void>
    if (
      interaccion.customId is not "panel-de-tickets-opciones"
      or interaccion.values[0] is not "apelacion" 
    ) return

    campos: TextInputBuilder[] := [
      new TextInputBuilder()
        .setLabel "Tipo de apelación"
        .setStyle TextInputStyle.Short
        .setRequired true
        .setCustomId "tipo"
      new TextInputBuilder()
        .setLabel "Descripción de la apelación"
        .setStyle TextInputStyle.Paragraph
        .setRequired true
        .setCustomId "descripcion"
    ]

    modal := new ModalBuilder()
      .setCustomId "panel-de-tickets-modal-apelacion"
      .setTitle "🙏 Crear ticket de apelación"
      .setComponents campos.map (campo) =>
        new ActionRowBuilder<TextInputBuilder>().setComponents campo
    
    await interaccion.showModal modal
  
  public @ async crearTicket(interaccion: ModalSubmitInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-modal-apelacion" return

    canalTicket := await Tickets.nuevo interaccion, "🙏-apelacion"
    if canalTicket is null
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true

      return

    { fields: campos, user: usuario } := interaccion
    
    datos :=
      tipo: campos.getTextInputValue "tipo"
      descripcion: campos.getTextInputValue "descripcion"
    
    embed := await @crearEmbedEstilizado()
    embed
      .setTitle "🙏 Ticket de apelación"
      .setFields [
        name: "Tipo de apelación"
        value: `> ${datos.tipo}`
        ,
        name: "Descripción de la apelación"
        value: datos.descripcion
          .split "\n"
          .map (linea) => `> ${linea}`
          .join "\n"
      ]

    { rolesDeAdministracion } := @api
    await rolesDeAdministracion.obtener()

    await canalTicket.send
      content: `${usuario} - <@&${rolesDeAdministracion.idAdministrador}>`
      embeds: [ embed ]
      components: [ Tickets.crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: `Ticket creado en ${canalTicket}`
      ephemeral: true

class OpcionDonacion < AccionesBase
  @opcion := new StringSelectMenuOptionBuilder()
    .setLabel "Donacion"
    .setEmoji "🪙"
    .setValue "donacion"

  public @ async mostrarModalRecolector(interaccion: StringSelectMenuInteraction): Promise<void>
    if (
      interaccion.customId is not "panel-de-tickets-opciones"
      or interaccion.values[0] is not "donacion" 
    ) return

    campos: TextInputBuilder[] := [
      new TextInputBuilder()
        .setLabel "Razón de la donación"
        .setStyle TextInputStyle.Paragraph
        .setRequired true
        .setCustomId "razon"
      new TextInputBuilder()
        .setLabel "Monto de la donación"
        .setStyle TextInputStyle.Short
        .setRequired true
        .setCustomId "monto"
    ]

    modal := new ModalBuilder()
      .setCustomId "panel-de-tickets-modal-donacion"
      .setTitle "🪙 Crear ticket de donación"
      .setComponents campos.map (campo) =>
        new ActionRowBuilder<TextInputBuilder>().setComponents campo
    
    await interaccion.showModal modal
  
  public @ async crearTicket(interaccion: ModalSubmitInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-modal-donacion" return

    canalTicket := await Tickets.nuevo interaccion, "🪙-donacion"
    if canalTicket is null
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true

      return

    { fields: campos, user: usuario } := interaccion
    
    datos :=
      razon: campos.getTextInputValue "razon"
      monto: campos.getTextInputValue "monto"
    
    embed := await @crearEmbedEstilizado()
    embed
      .setTitle "🪙 Ticket de donación"
      .setFields [
        name: "Razón de la donación"
        value: datos.razon
          .split "\n"
          .map (linea) => `> ${linea}`
          .join "\n"
      ,
        name: "Monto de la donación"
        value: `> ${datos.monto}`
      ]

    { rolesDeAdministracion } := @api
    await rolesDeAdministracion.obtener()

    await canalTicket.send
      content: `${usuario} - <@&${rolesDeAdministracion.idAdministrador}>`
      embeds: [ embed ]
      components: [ Tickets.crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: `Ticket creado en ${canalTicket}`
      ephemeral: true

class OpcionOtros < AccionesBase
  @opcion := new StringSelectMenuOptionBuilder()
    .setLabel "Otros"
    .setEmoji "❓"
    .setValue "otros"

  public @ async mostrarModalRecolector(interaccion: StringSelectMenuInteraction): Promise<void>
    if (
      interaccion.customId is not "panel-de-tickets-opciones"
      or interaccion.values[0] is not "otros" 
    ) return

    campos: TextInputBuilder[] := [
      new TextInputBuilder()
        .setLabel "Razón"
        .setStyle TextInputStyle.Paragraph
        .setRequired true
        .setCustomId "razon"
    ]

    modal := new ModalBuilder()
      .setCustomId "panel-de-tickets-modal-otros"
      .setTitle "❓ Crear ticket"
      .setComponents campos.map (campo) =>
        new ActionRowBuilder<TextInputBuilder>().setComponents campo
    
    await interaccion.showModal modal
  
  public @ async crearTicket(interaccion: ModalSubmitInteraction): Promise<void>
    if interaccion.customId is not "panel-de-tickets-modal-otros" return

    canalTicket := await Tickets.nuevo interaccion, "❓-otros"
    if canalTicket is null
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true

      return

    { fields: campos, user: usuario } := interaccion
    
    datos :=
      razon: campos.getTextInputValue "razon"
    
    embed := await @crearEmbedEstilizado()
    embed
      .setTitle "❓ Ticket"
      .setFields [
        name: "Razón"
        value: datos.razon
          .split "\n"
          .map (linea) => `> ${linea}`
          .join "\n"
      ]

    { rolesDeAdministracion } := @api
    await rolesDeAdministracion.obtener()

    await canalTicket.send
      content: `${usuario} - <@&${rolesDeAdministracion.idAdministrador}>`
      embeds: [ embed ]
      components: [ Tickets.crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: `Ticket creado en ${canalTicket}`
      ephemeral: true

class Tickets < AccionesBase
  public @ async nuevo(interaccion: Interaction, tipo: string): Promise<GuildTextBasedChannel | null>
    { tickets } := @api
    await tickets.obtener()

    { guild: servidor, user: usuario } := interaccion

    try {
      await servidor.channels.create 
        name: `${tipo}-${usuario.username}`
        parent: tickets.idCategoria
        permissionOverwrites: [
          id: servidor.roles.everyone
          deny: [ PermissionFlagsBits.ViewChannel ]
          ,
          id: usuario.id
          allow: [ PermissionFlagsBits.ViewChannel ]
        ]
    } catch error {
      this.log.error `Error al crear un ticket de ${tipo}: ${error}`
      return null
    }

  public @ crearControlesDeTicketAbierto(): ActionRowBuilder<ButtonBuilder>
    botones: ButtonBuilder[] := [
      new ButtonBuilder()
        .setStyle ButtonStyle.Primary
        .setEmoji "📢"
        .setLabel "Publicar ticket"
        .setCustomId "boton-publicar"
      new ButtonBuilder()
        .setStyle ButtonStyle.Secondary
        .setEmoji "❌"
        .setLabel "Cerrar ticket"
        .setCustomId "boton-cerrar"
    ]
    
    new ActionRowBuilder<ButtonBuilder>().setComponents botones
  
  public @ crearControlesDeTicketCerrado(): ActionRowBuilder<ButtonBuilder>
    botones: ButtonBuilder[] := [
      new ButtonBuilder()
        .setStyle ButtonStyle.Danger
        .setEmoji "🗑"
        .setLabel "Eliminar ticket"
        .setCustomId "boton-eliminar"
      new ButtonBuilder()
        .setStyle ButtonStyle.Primary
        .setEmoji "📖"
        .setLabel "Reabrir ticket"
        .setCustomId "boton-reabrir"
    ]

    new ActionRowBuilder<ButtonBuilder>().setComponents botones

  public @ async cerrarTicket(interaccion: ButtonInteraction): Promise<void>
    if interaccion.customId is not "boton-cerrar" return

    { channel: canal, message: mensaje } := interaccion

    idRolEveryone: string := interaccion.guild.roles.everyone.id
    canalEstaAbierto: boolean := canal
      .permissionsFor idRolEveryone
      .has PermissionFlagsBits.SendMessages

    if not canalEstaAbierto
      await interaccion.reply
        content: "El canal ya está cerrado"
        ephemeral: true

      return

    await canal
      .permissionOverwrites
      .edit idRolEveryone,
        SendMessages: false

    await mensaje.edit
      components: [ @crearControlesDeTicketCerrado() ]

    await interaccion.reply
      content: "Ticket cerrado!"
      ephemeral: true

  public @ async reabrirTicket(interaccion: ButtonInteraction): Promise<void>
    if interaccion.customId is not "boton-reabrir" return

    { channel: canal, message: mensaje } := interaccion

    idRolEveryone: string := interaccion.guild.roles.everyone.id
    canalEstaAbierto: boolean := canal
      .permissionsFor idRolEveryone
      .has PermissionFlagsBits.SendMessages
    
    if canalEstaAbierto
      await interaccion.reply
        content: "El canal ya está abierto"
        ephemeral: true
      
      return

    await canal
      .permissionOverwrites
      .edit idRolEveryone,
        SendMessages: true

    await mensaje.edit
      components: [ @crearControlesDeTicketAbierto() ]

    await interaccion.reply
      content: "Ticket reabierto!"
      ephemeral: true
    
  public @ async publicarTicket(interaccion: ButtonInteraction): Promise<void>
    if interaccion.customId is not "boton-publicar" return

    { channel: canal, message: mensaje } := interaccion
    { rolesDeAdministracion } := @api

    await rolesDeAdministracion.obtener()
    if not rolesDeAdministracion.idStaff
      await interaccion.reply
        content: "Ocurrió un error al ejecutar esta interacción"
        ephemeral: true
      
      return

    canalEstaPublicado: boolean := canal
      .permissionsFor rolesDeAdministracion.idStaff
      .has PermissionFlagsBits.ViewChannel

    if canalEstaPublicado
      await interaccion.reply
        content: "El canal ya estaba publicado"
        ephemeral: true

      return

    await canal
      .permissionOverwrites
      .edit rolesDeAdministracion.idStaff,
        ViewChannel: true

    await interaccion.reply
      content: "El canal ha sido publicado!"
      ephemeral: true

  public @ async eliminarTicket(interaccion: ButtonInteraction): Promise<void>
    if interaccion.customId is not "boton-eliminar" return

    { channel: canal, message: mensaje, member: miembro } := interaccion

    if not @esAdmin miembro as GuildMember
      await interaccion.reply
        content: "No tienes permisos para ejecutar esta interacción"
        ephemeral: true

      return

    await interaccion.reply
      content: "Eliminando este ticket..."
      
    setTimeout => await canal.delete(), 5000
